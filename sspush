#!/usr/bin/env bash
#
# sspush
# Date: 5/9/2023
#
# A tool for macOS and Linux that pushes a screencapture/image/file 
# to a remote web server of your choosing via scp.
# 
# by CtrlAltMech
#


# Exit on error
set -e

# Configuration path
readonly CONFIG="$HOME/.config/sspushrc"

# Main logic
main () {
    conf_check
    path_verify
    # from here on we just work with $REMOTEDIR, since we know it's got a / at the end
    display_serv_check
    clipboard_check

    if [[ -z "$1" ]]; then # No argument, pushes most recent screencap in folder
        find_file
        echo "Your most recent file is $(basename "$orig_file")"
        push_logic
        exit 0

    elif [[ -e "$1" ]]; then # Pushes file specified in argument
        find_file "$1"
        echo "Your selected file is $(basename "$orig_file")"
        push_logic
        exit 0
    fi

    while getopts ':iah' OPTION;  
    do
        case "$OPTION" in
            i) # Interactive screencapture option
                if [[ "$#" -ge 3 ]]; then
                    help_msg
                    exit 1
                else
                    screen_handler "$1" "$2"
                fi
            ;;
            
            a) # Capture everything
                if [[ "$#" -ge 3 ]]; then
                    help_msg
                    exit 1
                else
                    screen_handler "$1" "$2"
                fi
            ;;

            h) # Print syntax help
                help_msg
                exit 1
            ;;

            \?)
                help_msg
                exit 1
            ;;
        esac
    done
}

# Help message
help_msg () {
    echo "Syntax: $(basename "$0") [-i|-a]  /optional/file/path/"
    echo "options:"
    echo "-i    Interactive mode, select portion of screen to capture and push to server."
    echo "-a    Capture everything on screen and push to server."
}

# Handles which screencapture utility to use based on display server.
screen_handler () {
    local arg="$1"
    local filepath="$2"

    if [[ -z "$filepath" ]]; then 
        filepath=$SSFILEPATH"Screencapture_$(date +"%Y%m%d_%H%M%S").png"; 
    else
        filepath=$SSFILEPATH$2
    fi

    case "$disp_server" in
        wayland)
            echo "Screencapture in progress, file created: $(basename "$filepath")"
            wayland_screencapture "$arg" "$filepath"
            ;;

        x11)
            echo "Screencapture in progress, file created: $(basename "$filepath")"
            x11_screencapture "$arg" "$filepath"
            ;;

        macos)
            echo "Screencapture in progress, file created: $(basename "$filepath")"
            mac_screencapture "$arg" "$filepath"
            ;;
    esac
}

path_verify () {
    # ensure the remotepath ends in a /
    # since we're concatenating the path with the name of the generated file
    # path + '/' + filename.png
    local remote_path_len=${#REMOTEDIR}
    local last_char=${REMOTEDIR:remote_path_len-1:1}
    if [[ $last_char != '/' ]]; then
        REMOTEDIR=$REMOTEDIR'/'
    fi

    local local_path_len=${#SSFILEPATH}
    local last_char=${SSFILEPATH:local_path_len-1:1}
    if [[ $last_char != '/' ]]; then
        SSFILEPATH=$SSFILEPATH'/'
    fi
}

# Checks for config file, prompt to create if none exists.
# If config file exists, make sure its filled out.
conf_check () {
    if ! [[ -f $CONFIG ]]; then
        conf_prompt
    else
        # shellcheck source-path=SCRIPTDIR/../../.config/
        # shellcheck source=sspushrc
        . "$CONFIG" 
        conf_var_check 
    fi
}

# Clipboard check
clipboard_check () {
    case $disp_server in
        wayland)
            clip_util="wl-copy"
            [[ $CLIPBOARD == "clipboard" ]] || clip_util="wl-copy --primary"
            ;;
        x11)
            clip_util="xclip -i"
            ;;
        macos)
            clip_util="pbcopy"
            ;;
        *)
            echo "Unable to determine display server. Exiting..."
            exit 1
            ;;
    esac
}

# If no configuration file is seen it will prompt to generate one 
conf_prompt () {
    local conf_choice
    read -p "No configuration file found. Would you like to create one? (y/n): " conf_choice
    
    while ! [[ $conf_choice =~ (^y$|^Y$|^n$|^N$) ]]
    do
        read -pr "Not a valid option. Would you like to create a config file? (y/n): " conf_choice
    done

    if [[ $conf_choice =~ (^y$|^Y$) ]]; then
        conf_make
    elif [[ "$conf_choice" =~ (^n$|^N$) ]]; then
        echo "Goodbye!"
        exit 0
    fi
}

# Creates the configuration file
conf_make () {
    
	cat <<- EOF > "$CONFIG"
	# Config file for sspush
	 
	# Filepath where screenshots are stored
	SSFILEPATH=""
	
	# Remote directory where screenshots are stored
	REMOTEDIR=""
	
	# Username for access to server
	USERNAME="$USER"
	
	# Private key location (script only works with ssh keys)
	KEYPATH=""
	
	# SSH port
	PORT="22"
	
	# Server IP or DNS name
	SERVER=""
	
	# Base link location (Link minus the image that the user will visit).
	# Example https://mysite.net/pics/<your image name>.jpg"
	BASELINK=""
	
	# Allow/Deny desktop notifications
	NOTIFICATIONS=""
	
	# Specify which clipboard to use (clipboard or primary)
	CLIPBOARD="clipboard"

	EOF
    echo "Config file $CONFIG created!"
    $EDITOR $CONFIG # Open config in editor
    exit 0
}

# Checks which display server is running
display_serv_check () {
    if [[ "$XDG_SESSION_TYPE" == "wayland" ]]; then
        disp_server="wayland"
        CAPTURE=grim
    elif [[ "$XDG_SESSION_TYPE" == "x11" ]]; then
        disp_server="x11"
        CAPTURE=maim
    elif [[ "$XDG_SESSION_TYPE" == "" ]]; then
        disp_server="macos" # macOS does not use XDG by default
        CAPTURE=screencapture
    fi
}

# Verify that all configuration variables have been set, error if not
conf_var_check () {
    local msg="All configuration variables need to be set at runtime."
    : "${SSFILEPATH:?$msg}" 
    : "${REMOTEDIR:?$msg}" 
    : "${USERNAME:?$msg}" 
    : "${KEYPATH:?$msg}" 
    : "${PORT:?$msg}" 
    : "${SERVER:?$msg}" 
    : "${BASELINK:?$msg}" 
    : "${NOTIFICATIONS:?$msg}" 
    : "${CLIPBOARD:?$msg}" 
} 

# Creates the new randomly generated filename for the remote destination
name_gen () {
    local filename=$1
    local extension=${filename##*.}
    filename=$(echo $RANDOM | md5sum | head -c 8; echo;)
    generated_name="$filename.$extension"
}

# macOS screencapture handler
mac_screencapture () {
    case "$1" in
        -i)
            $CAPTURE -i "$2"
            find_file "$2"
            push_logic
        ;;

        -a)
            $CAPTURE "$2"
            find_file "$2"
            push_logic
        ;;
    esac
}

# Wayland screencapture
wayland_screencapture () {
    case "$1" in
        -i)
            $CAPTURE -g "$(slurp)" "$2"
            find_file "$2"
            push_logic
        ;;

        -a)
            $CAPTURE "$2"
            find_file
            push_logic
        ;;
    esac
}

# X11 screencapture 
x11_screencapture () {
    case "$1" in
        -i)
            $CAPTURE -s "$2"
            find_file "$2"
            push_logic
        ;;

        -a)
            $CAPTURE "$2"
            find_file
            push_logic
        ;;
    esac
} 

# Finds the file to push to remote server
find_file() {
    if [[ "$(ls -A "$SSFILEPATH" 2>/dev/null)" ]] && [[ -z "$1" ]]; then # No argument provided, most recent file found
        orig_file="$SSFILEPATH"$(ls -Art "$SSFILEPATH" | tail -n 1)
        name_gen "$(ls -Art "$SSFILEPATH" | tail -n 1)"
    elif [[ "$(ls -A "$1"  2>/dev/null)" ]] && [[ -n "$1" ]]; then # Argument provided. Pick selected photo.
        orig_file="$1"
        name_gen "$1"
    else
        echo "File not found. Try again..."
        exit 1
    fi
}

# Takes all the curated information, pushes it to the server, provides a link
push_logic () {
    scp -i "$KEYPATH" "$orig_file" "$USERNAME@$SERVER":"$REMOTEDIR$generated_name" # Transfer that file to the remote server
    case "$disp_server" in
        macos)
            echo "$BASELINK$generated_name" | pbcopy
            ;;
        x11)
            echo "$BASELINK$generated_name" | xclip
            ;;
        wayland)
            echo "$BASELINK$generated_name" | wl-copy
            ;;
        *)
            echo "Unable to determine clipboard utility, nothing copied...."
            echo "Link to file $BASELINK$generated_name"
            exit 1
            ;;
    esac

    echo "Link $BASELINK$generated_name has been copied to clipboard!"
}

main "$@"
