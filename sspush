#!/usr/bin/env bash
#
# sspush
# Date: 5/9/2023
#
# A tool for macOS and Linux that pushes a screencapture/image/file 
# to a remote web server of your choosing via scp.
# 
# by CtrlAltMech
#


# Exit on error
set -e
# set -x
# Configuration path
readonly CONFIG="$HOME/.config/sspushrc"

# Main logic
main () {
    conf_check

    if [[ -z "$1" ]]; then
        find_file
        echo "Your selected file is $(basename "$orig_file")"
        push_logic
        exit 0

    elif [[ -e "$1" ]]; then
        find_file "$1"
        echo "Your selected file is $(basename "$orig_file")"
        push_logic
        exit 0
    fi

    while getopts ':ia' OPTION; # Look into just using a case statement 
    do
        case "$OPTION" in
            i) # Interactive screencapture option
                if [[ "$#" -ge 3 ]]; then
                    echo "Only accepts one option and a filepath."
                    exit 1
                else
                    screen_handler "$1" "$2"
                fi
            ;;
            
            a) # Capture everything
                if [[ "$#" -ge 3 ]]; then
                    echo "Only accepts one option and a filepath."
                    exit 1
                else
                    screen_handler "$1" "$2"
                fi
            ;;
            # TODO add the rest of the options
            \?)
                # TODO cleanup, compare with better scripts. --help option?
                echo "Usage: $(basename "$0") [-i] [-a]  /optional/file/path/"
                exit 1
            ;;
        esac
    done
}

# Screencapture handler
screen_handler () {
    local arg="$1"
    local filepath="$2"
    
    # TODO, look into better way to use less if statements or improve current.
    if [[ -z "$filepath" ]]; then 
        filepath=$SSFILEPATH"Screencapture_$(date +"%Y%m%d_%H%M%S").png"; 
    else
        filepath=$SSFILEPATH$2
    fi
    # TODO probably make this a case statement
    if [[ "$(display_serv_check)" == "wayland" ]]; then
        echo "Your selected file is $(basename "$filepath")"
        wayland_screencapture "$arg" "$filepath"
    elif [[ "$(display_serv_check)" == "x11" ]]; then
        x11_screencapture "$arg" "$filepath"
    elif [[ "$(display_serv_check)" == "macos" ]]; then
        mac_screencapture "$arg" "$filepath"
    fi

path_verify () {
    # ensure the remotepath ends in a /
    # since we're concatenating the path with the name of the generated file
    # path + '/' + filename.png
    local remote_path_len=${#REMOTEDIR}
    local last_char=${REMOTEDIR:remote_path_len-1:1}
    if [[ $last_char != '/' ]]; then
        REMOTEDIR=$REMOTEDIR'/'
    fi

    local local_path_len=${#SSFILEPATH}
    local last_char=${SSFILEPATH:local_path_len-1:1}
    if [[ $last_char != '/' ]]; then
        SSFILEPATH=$SSFILEPATH'/'
    fi
}

# Configuration check
conf_check () {
    if ! [[ -f $CONFIG ]]; then
        conf_prompt
    else
        # TODO use directive to specify location per ShellCheck 
        . "$CONFIG" 
        conf_var_check 
    fi
}

# Clipboard check
clipboard_check () {
    # TODO probably also a case statement if I don't find a better way.
    if [[ "$disp_server" == "wayland" ]]; then
       echo "wl-copy"
    elif [[ "$disp_server" == "x11" ]]; then 
       echo "xclip"
    elif [[ "$disp_server" == "" ]]; then
        echo "pbcopy"
    else
        echo "Unable to determine OS. Exiting..."
        exit 1
    fi
}

# If no configuration file is seen it will prompt to generate one 
conf_prompt () {
    # TODO make read prompt variable conf_choice variable local
    read -p "No configuration file found. Would you like to create one? (y/n): " conf_choice
    
    while ! [[ $conf_choice =~ (^y$|^Y$|^n$|^N$) ]]
    do
        read -pr "Not a valid option. Would you like to create a config file? (y/n): " conf_choice
    done
    if [[ $conf_choice =~ (^y$|^Y$) ]]; then
        conf_make
    elif [[ "$conf_choice" =~ (^n$|^N$) ]]; then
        echo "Goodbye!"
        exit 0
    fi
}

# Creates the configuration file
conf_make () {
    
	cat <<- EOF > "$CONFIG"
	# Config file for sspush
	 
	# Filepath where screenshots are stored
	SSFILEPATH=""
	
	# Remote directory where screenshots are stored
	REMOTEDIR=""
	
	# Username for access to server
	USERNAME="$USER"
	
	# Private key location (script only works with ssh keys)
	KEYPATH=""
	
	# SSH port
	PORT="22"
	
	# Server IP or DNS name
	SERVER=""
	
	# Base link location (Link minus the image that the user will visit).
	# Example https://mysite.net/pics/<your image name>.jpg"
	BASELINK=""
	
	# Allow/Deny desktop notifications
	NOTIFICATIONS=""

  # Specify which clipboard to use (clipboard or primary)
  CLIPBOARD="clipboard"

	EOF
    echo "Config file $CONFIG created!"
    $EDITOR $CONFIG
    exit 0
}

# Checks what OS this is running on
# TODO probably don't need as I will use display server to dictacte actions
os_check () {
    if [[ "$(uname -s)" == "Darwin" ]]; then
        echo "Darwin"
    elif [[ "$(uname -s)" == "Linux" ]]; then
        echo "Linux"
    fi
}

# Checks which display server is running
display_serv_check () {
    if [[ "$XDG_SESSION_TYPE" == "wayland" ]]; then
        echo "wayland"
    elif [[ "$XDG_SESSION_TYPE" == "x11" ]]; then
        echo "x11"
    elif [[ "$XDG_SESSION_TYPE" == "" ]]; then
        echo "macos" # I know this is not a display server
    fi
}

# Verify that all configuration variables have been set, error if not
conf_var_check () {
    local msg="All configuration variables need to be set at runtime."
    : "${SSFILEPATH:?$msg}" 
    : "${REMOTEDIR:?$msg}" 
    : "${USERNAME:?$msg}" 
    : "${KEYPATH:?$msg}" 
    : "${PORT:?$msg}" 
    : "${SERVER:?$msg}" 
    : "${BASELINK:?$msg}" 
    : "${NOTIFICATIONS:?$msg}" 
    : "${CLIPBOARD:?$msg}" 
} 

# Creates the new randomly generated filename for the remote destination
name_gen () {
    local filename=$1
    local extension=${filename##*.}
    filename=$(echo $RANDOM | md5sum | head -c 8; echo;)
    generated_name="$filename.$extension"
}

# macOS screencapture handler
mac_screencapture () {
    # TODO keeping these for now, might use eventually for other mac options
    # local option_pattern_full="^-b$|^-C$|^-i$|^-m$|^-v[g]?$"
    # local image_pattern="^-b$|^-C$|^-i$|^-m$"
    # local vid_pattern="^-v[g]?$"
    case "$1" in
        -i)
            screencapture -i "$2"
            find_file "$2"
            push_logic
        ;;

        -a)
            screencapture "$2"
            find_file "$2"
            push_logic
        ;;
    esac
}

# Wayland screencapture
wayland_screencapture () {
    case "$1" in
        -i)
            grim -g "$(slurp)" "$2"
            find_file "$2"
            push_logic
        ;;

        -a)
            grim "$2"
            find_file
            push_logic
        ;;
    esac
}

# X11 screencapture 
# TODO placeholder for x11 screencapture
x11_screencapture () {
    :
} 

# Finds the file to push to remote server
find_file() {
    if [[ "$(ls -A "$SSFILEPATH" 2>/dev/null)" ]] && [[ -z "$1" ]]; then # No argument provided, most recent file found
        orig_file="$SSFILEPATH"$(ls -Art "$SSFILEPATH" | tail -n 1)
        name_gen "$(ls -Art "$SSFILEPATH" | tail -n 1)"
    elif [[ "$(ls -A "$1"  2>/dev/null)" ]] && [[ -n "$1" ]]; then # Argument provided. Pick selected photo.
        orig_file="$1"
        name_gen "$1"
    else
        echo "FILE NOT FOUND!"
        exit 1
    fi
}

# Takes all the curated information, pushes it to the server, provides a link
# TODO There is a much better way to do this. BAD
push_logic () {
    scp -i "$KEYPATH" "$orig_file" "$USERNAME@$SERVER":"$REMOTEDIR$generated_name" # Transfer that file to the remote server
    if [[ $(display_serv_check) == "macos" ]]; then
        echo "$BASELINK$generated_name" | pbcopy # Copies to macOS clipboard
    elif [[ $(display_serv_check) == "x11" ]]; then
        echo "$BASELINK$generated_name" | xclip # Copies to xclip clipboard
    elif [[ $(display_serv_check) == "wayland" ]]  && [[ $CLIPBOARD == "clipboard" ]]; then
        echo "$BASELINK$generated_name" | wl-copy # Copies to wl-copy clipboard 
    elif [[ $(display_serv_check) == "wayland" ]]  && [[ $CLIPBOARD == "primary" ]]; then
        echo "$BASELINK$generated_name" | wl-copy --primary # Copies to wl-copy primary clipboard 
    else
        echo "Unable to determine clipboard utility, nothing copied...."
        echo "Link to file $BASELINK$generated_name"
        exit 1
    fi
    echo "Link $BASELINK$generated_name has been copied to clipboard!"
}

main "$@"
